{"ast":null,"code":"import express from \"express\";\nimport { db } from \"../db/conn.mjs\"; // Import db from conn.mjs\nimport bcrypt from \"bcrypt\";\nimport jwt from \"jsonwebtoken\";\nimport ExpressBrute from \"express-brute\";\nimport dotenv from \"dotenv\";\ndotenv.config(); // Load environment variables from .env file\n\nconst router = express.Router();\nconst store = new ExpressBrute.MemoryStore(); // Don't use this in production\nconst bruteforce = new ExpressBrute(store); // Global brute-force instance\n\nconst secretKey = process.env.SECRET_KEY; // Read secret key from environment variable\n\n// Function to sanitize input\nconst sanitizeInput = input => {\n  if (typeof input === 'string') {\n    return input.replace(/[<>]/g, \"\"); // Remove potentially harmful characters\n  }\n  return input;\n};\n\n// Employee Login\nrouter.post(\"/emplogin\", bruteforce.prevent, async (req, res) => {\n  try {\n    const {\n      username,\n      password\n    } = req.body;\n    const errors = [];\n\n    // Check if all required fields are provided\n    if (!username) errors.push({\n      field: 'username',\n      message: 'Username is required'\n    });\n    if (!password) errors.push({\n      field: 'password',\n      message: 'Password is required'\n    });\n    if (errors.length > 0) {\n      return res.status(400).json({\n        errors\n      });\n    }\n\n    // Sanitize username\n    const sanitizedUsername = sanitizeInput(username);\n\n    // Find the employee in the Employee collection\n    const collection = await db.collection(\"Employees\");\n    const employee = await collection.findOne({\n      username: sanitizedUsername\n    }); // Safe comparison\n\n    if (!employee) {\n      console.log(\"Employee not found\");\n      return res.status(401).json({\n        errors: [{\n          field: 'general',\n          message: 'Username or password could be incorrect'\n        }]\n      });\n    }\n\n    // Compare the provided password with the hashed password in the database\n    const passwordMatch = await bcrypt.compare(password, employee.password);\n    if (!passwordMatch) {\n      console.log(\"Password mismatch\");\n      return res.status(401).json({\n        errors: [{\n          field: 'general',\n          message: 'Username or password could be incorrect'\n        }]\n      });\n    } else {\n      // Authentication successful\n      const token = jwt.sign({\n        username: employee.username\n      }, secretKey, {\n        expiresIn: \"30m\"\n      });\n      res.status(200).json({\n        message: \"Authentication successful\",\n        token,\n        username: employee.username\n      });\n    }\n  } catch (error) {\n    console.log(\"Employee Login Error:\", error);\n    res.status(500).json({\n      message: \"Login Failed\"\n    });\n  }\n});\n\n// Employee Forgot Password\nrouter.post(\"/forgot-password\", async (req, res) => {\n  try {\n    const {\n      username,\n      newPassword,\n      confirmPassword\n    } = req.body;\n\n    // Check if all required fields are provided\n    if (!username || !newPassword || !confirmPassword) {\n      console.log(\"Missing fields:\", {\n        username,\n        newPassword,\n        confirmPassword\n      });\n      return res.status(400).json({\n        errors: [{\n          field: 'general',\n          message: \"All fields are required\"\n        }]\n      });\n    }\n\n    // Check if newPassword and confirmPassword match\n    if (newPassword !== confirmPassword) {\n      console.log(\"Passwords do not match:\", {\n        newPassword,\n        confirmPassword\n      });\n      return res.status(400).json({\n        errors: [{\n          field: 'confirmPassword',\n          message: \"Passwords do not match\"\n        }]\n      });\n    }\n\n    // Sanitize username\n    const sanitizedUsername = sanitizeInput(username);\n\n    // Find the employee in the Employees collection using sanitized username\n    const collection = await db.collection(\"Employees\");\n    const employee = await collection.findOne({\n      username: sanitizedUsername\n    }); // Safe comparison\n\n    if (!employee) {\n      console.log(\"Employee not found:\", sanitizedUsername);\n      return res.status(404).json({\n        errors: [{\n          field: 'username',\n          message: \"Employee not found\"\n        }]\n      });\n    }\n\n    // Hash the new password asynchronously\n    const saltRounds = 10;\n    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);\n\n    // Update the employee's password in the database\n    const updateResult = await collection.updateOne({\n      _id: employee._id\n    }, {\n      $set: {\n        password: hashedPassword\n      }\n    });\n    if (updateResult.modifiedCount === 0) {\n      console.log(\"Password update failed for employee:\", sanitizedUsername);\n      return res.status(500).json({\n        errors: [{\n          field: 'general',\n          message: \"Password update failed\"\n        }]\n      });\n    }\n    res.status(200).json({\n      message: \"Password has been reset successfully\"\n    });\n  } catch (error) {\n    console.log(\"Forgot Password Error:\", error);\n    res.status(500).json({\n      errors: [{\n        field: 'general',\n        message: \"Forgot Password Failed\"\n      }]\n    });\n  }\n});\nexport default router;","map":{"version":3,"names":["express","db","bcrypt","jwt","ExpressBrute","dotenv","config","router","Router","store","MemoryStore","bruteforce","secretKey","process","env","SECRET_KEY","sanitizeInput","input","replace","post","prevent","req","res","username","password","body","errors","push","field","message","length","status","json","sanitizedUsername","collection","employee","findOne","console","log","passwordMatch","compare","token","sign","expiresIn","error","newPassword","confirmPassword","saltRounds","hashedPassword","hash","updateResult","updateOne","_id","$set","modifiedCount"],"sources":["C:/Users/vicky/OneDrive - ADvTECH Ltd/Varsity college/Third Year/Second Semester/APDS7311/POE/2/Main/APDS_POE/FRONT END/frontend/src/components/employeeLogin.js"],"sourcesContent":["import express from \"express\";\r\nimport { db } from \"../db/conn.mjs\"; // Import db from conn.mjs\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport ExpressBrute from \"express-brute\";\r\nimport dotenv from \"dotenv\";\r\n\r\ndotenv.config(); // Load environment variables from .env file\r\n\r\nconst router = express.Router();\r\nconst store = new ExpressBrute.MemoryStore(); // Don't use this in production\r\nconst bruteforce = new ExpressBrute(store); // Global brute-force instance\r\n\r\nconst secretKey = process.env.SECRET_KEY; // Read secret key from environment variable\r\n\r\n// Function to sanitize input\r\nconst sanitizeInput = (input) => {\r\n  if (typeof input === 'string') {\r\n    return input.replace(/[<>]/g, \"\"); // Remove potentially harmful characters\r\n  }\r\n  return input;\r\n};\r\n\r\n// Employee Login\r\nrouter.post(\"/emplogin\", bruteforce.prevent, async (req, res) => {\r\n  try {\r\n    const { username, password } = req.body;\r\n\r\n    const errors = [];\r\n\r\n    // Check if all required fields are provided\r\n    if (!username) errors.push({ field: 'username', message: 'Username is required' });\r\n    if (!password) errors.push({ field: 'password', message: 'Password is required' });\r\n\r\n    if (errors.length > 0) {\r\n      return res.status(400).json({ errors });\r\n    }\r\n\r\n    // Sanitize username\r\n    const sanitizedUsername = sanitizeInput(username);\r\n\r\n    // Find the employee in the Employee collection\r\n    const collection = await db.collection(\"Employees\");\r\n    const employee = await collection.findOne({ username: sanitizedUsername }); // Safe comparison\r\n\r\n    if (!employee) {\r\n      console.log(\"Employee not found\");\r\n      return res.status(401).json({ errors: [{ field: 'general', message: 'Username or password could be incorrect' }] });\r\n    }\r\n\r\n    // Compare the provided password with the hashed password in the database\r\n    const passwordMatch = await bcrypt.compare(password, employee.password);\r\n    if (!passwordMatch) {\r\n      console.log(\"Password mismatch\");\r\n      return res.status(401).json({ errors: [{ field: 'general', message: 'Username or password could be incorrect' }] });\r\n    } else {\r\n      // Authentication successful\r\n      const token = jwt.sign({ username: employee.username }, secretKey, { expiresIn: \"30m\" });\r\n      res.status(200).json({ message: \"Authentication successful\", token, username: employee.username });\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Employee Login Error:\", error);\r\n    res.status(500).json({ message: \"Login Failed\" });\r\n  }\r\n});\r\n\r\n// Employee Forgot Password\r\nrouter.post(\"/forgot-password\", async (req, res) => {\r\n  try {\r\n    const { username, newPassword, confirmPassword } = req.body;\r\n\r\n    // Check if all required fields are provided\r\n    if (!username || !newPassword || !confirmPassword) {\r\n      console.log(\"Missing fields:\", { username, newPassword, confirmPassword });\r\n      return res.status(400).json({ errors: [{ field: 'general', message: \"All fields are required\" }] });\r\n    }\r\n\r\n    // Check if newPassword and confirmPassword match\r\n    if (newPassword !== confirmPassword) {\r\n      console.log(\"Passwords do not match:\", { newPassword, confirmPassword });\r\n      return res.status(400).json({ errors: [{ field: 'confirmPassword', message: \"Passwords do not match\" }] });\r\n    }\r\n\r\n    // Sanitize username\r\n    const sanitizedUsername = sanitizeInput(username);\r\n\r\n    // Find the employee in the Employees collection using sanitized username\r\n    const collection = await db.collection(\"Employees\");\r\n    const employee = await collection.findOne({ username: sanitizedUsername }); // Safe comparison\r\n\r\n    if (!employee) {\r\n      console.log(\"Employee not found:\", sanitizedUsername);\r\n      return res.status(404).json({ errors: [{ field: 'username', message: \"Employee not found\" }] });\r\n    }\r\n\r\n    // Hash the new password asynchronously\r\n    const saltRounds = 10;\r\n    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);\r\n\r\n    // Update the employee's password in the database\r\n    const updateResult = await collection.updateOne({ _id: employee._id }, { $set: { password: hashedPassword } });\r\n\r\n    if (updateResult.modifiedCount === 0) {\r\n      console.log(\"Password update failed for employee:\", sanitizedUsername);\r\n      return res.status(500).json({ errors: [{ field: 'general', message: \"Password update failed\" }] });\r\n    }\r\n\r\n    res.status(200).json({ message: \"Password has been reset successfully\" });\r\n  } catch (error) {\r\n    console.log(\"Forgot Password Error:\", error);\r\n    res.status(500).json({ errors: [{ field: 'general', message: \"Forgot Password Failed\" }] });\r\n  }\r\n});\r\n\r\nexport default router;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}